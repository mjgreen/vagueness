
## lm model in logRT

```{r, results='asis', cache=FALSE, eval=TRUE}
lm.logRT.0 <- lm (logRT ~  c_Trl + expos.c + expos.q +
                    c_Num + c_Vag + Quantity + Order +
                    c_Num : c_Vag , dat)
co <- as.data.frame(summary(lm.logRT.0)$coef)
# do stars
x=co[,"Pr(>|t|)"]
s=rep(NA, times=length(x))
for (i in 1:length(x)) {s[i]=ifelse(x[i]<.001, "$***$", ifelse(x[i]<.01,"$**$", ifelse(x[i]<.05,"$*$",  ifelse(x[i]<.1, "ยง", " "))))}
# cut p value into minimum <.001
p=rep(NA, times=length(x))
for (i in 1:length(x)) {p[i] <- as.character(ifelse(x[i]<.001, "<0.001", formatC(round(x[i],3), format='f', digits=3)))}
# bind coefs with p and s
dd=data.frame(beta=rownames(co), Estimate=co[,1], Std_Error=co[,2], t_value = co[,3], p_value = p, signif=s, row.names=NULL)
print(  xtable (dd, caption="Signif. codes: $***$ < 0.001; $**$ < 0.01; $*$ < 0.05; ยง < 0.1", align=rep("r",times=length(dd)+1)), type='html', include.rownames=FALSE)

```

## lmer models in logRT

```{r, eval=TRUE, cache=TRUE, warning=TRUE, message=TRUE}
# baseline model should be without experimental manipulations because rt is typically mostly detrmined by mean RT and practice/fatigue
lmer(data=dat, logRT ~ (1 | Subject) + (1 | f_Itm) ) -> m0
lmer(data=dat, logRT ~ s_Trl + (1 | Subject) + (1 | f_Itm) ) -> m1
lmer(data=dat, logRT ~ s_Trl + (1 + s_Trl | Subject) + (1 | f_Itm) ) -> m2
lmer(data=dat, logRT ~ s_Trl + (1 + s_Trl | Subject) + (1 + s_Trl | f_Itm) ) -> m3
# add in experimental manipulations
lmer(data=dat, logRT ~ s_Trl + c_Num + (1 + s_Trl | Subject) + (1 + s_Trl | f_Itm) ) -> m4
lmer(data=dat, logRT ~ s_Trl + c_Num + (1 + s_Trl + c_Num | Subject) + (1 + s_Trl | f_Itm) ) -> m5
lmer(data=dat, logRT ~ s_Trl + c_Num + (1 + s_Trl + c_Num | Subject) + (1 + s_Trl + c_Num | f_Itm) ) -> m6
lmer(data=dat, logRT ~ s_Trl + c_Num + c_Vag + (1 + s_Trl + c_Num | Subject) + (1 + s_Trl + c_Num | f_Itm) ) -> m7
lmer(data=dat, logRT ~ s_Trl + c_Num + c_Vag + (1 + s_Trl + c_Num + c_Vag | Subject) + (1 + s_Trl + c_Num | f_Itm) ) -> m8
lmer(data=dat, logRT ~ s_Trl + c_Num + c_Vag + (1 + s_Trl + c_Num + c_Vag | Subject) + (1 + s_Trl + c_Num + c_Vag | f_Itm) ) -> m9
``` 

```{r, eval=TRUE, cache=TRUE, warning=TRUE, message=TRUE}
# interactions of number and vagueness
lmer(data=dat, logRT ~ s_Trl + c_Num * c_Vag + (1 + s_Trl + c_Num + c_Vag | Subject) + (1 + s_Trl + c_Num + c_Vag | f_Itm) ) -> m10 # no interaction in the randoms
lmer(data=dat, logRT ~ s_Trl + c_Num * c_Vag + (1 + s_Trl + c_Num * c_Vag | Subject) + (1 + s_Trl + c_Num + c_Vag | f_Itm) ) -> m11 # interaction in the subjects only * vs m10
# no converge below
lmer(data=dat, logRT ~ s_Trl + c_Num * c_Vag + (1 + s_Trl + c_Num + c_Vag | Subject) + (1 + s_Trl + c_Num * c_Vag | f_Itm) ) -> m12 # interaction in the items only no converge
# no converge below
lmer(data=dat, logRT ~ s_Trl + c_Num * c_Vag + (1 + s_Trl + c_Num * c_Vag | Subject) + (1 + s_Trl + c_Num * c_Vag | f_Itm) ) -> m13 # interaction in both randoms no converge
# no converge below
lmer(data=dat, logRT ~ s_Trl + c_Num * c_Vag + c_Qty + (1 + s_Trl + c_Num * c_Vag | Subject) + (1 + s_Trl + c_Num * c_Vag | f_Itm) ) -> m14 # interaction in both randoms, add Q, no converge
```

```{r, eval=TRUE, cache=TRUE, warning=TRUE, message=TRUE}
lmer(data=dat, logRT ~ s_Trl + c_Num * c_Vag + c_Qty + (1 + s_Trl + c_Num + c_Vag | Subject) + (1 + s_Trl + c_Num + c_Vag | f_Itm) ) -> m15 # no interaction in the randoms, add Q. *** vs m10
lmer(data=dat, logRT ~ s_Trl + c_Num * c_Vag * c_Qty + (1 + s_Trl + c_Num + c_Vag | Subject) + (1 + s_Trl + c_Num + c_Vag | f_Itm) ) -> m17 # no interaction in the randoms, add interaction Q ** vs m15
lmer(data=dat, logRT ~ s_Trl + c_Num * c_Vag * c_Qty + (1 + s_Trl + c_Num * c_Vag | Subject) + (1 + s_Trl + c_Num + c_Vag | f_Itm) ) -> m18 # interaction in the subjects only, keep interaction Q
lmer(data=dat, logRT ~ s_Trl + c_Num * c_Vag * c_Qty + (1 + s_Trl + c_Num * c_Vag | Subject) + (1 + s_Trl + c_Num * c_Vag | f_Itm) ) -> m19 # interaction in both randoms, keep interaction Q
# no converge below
lmer(data=dat, logRT ~ s_Trl + c_Num * c_Vag * c_Qty + c_Ord + (1 + s_Trl + c_Num * c_Vag | Subject) + (1 + s_Trl + c_Num * c_Vag | f_Itm) ) -> m20 # interaction in both randoms, keep interaction Q, add Ord
```


## invlam section

```{r, eval=TRUE, cache=TRUE, warning=TRUE, message=TRUE}
# no converge below
lmer(data=dat, invlam ~ s_Trl + c_Num * c_Vag * c_Qty + (1 + s_Trl + c_Num * c_Vag | Subject) + (1 + s_Trl + c_Num * c_Vag | f_Itm) ) -> m19.i # no converge
lmer(data=dat, invlam ~ s_Trl + c_Num * c_Vag * c_Qty + c_Ord + (1 + s_Trl + c_Num * c_Vag | Subject) + (1 + s_Trl + c_Num * c_Vag | f_Itm) ) -> m20.i # interaction in both randoms, keep interaction Q, add Ord
```





## Borderline response

```{r, eval=TRUE, cache=FALSE}
round(table(dat$Response) / nrow(dat) * 100, 0)
```

```{r, eval=TRUE, cache=FALSE}
round(table(dat$Vagueness, dat$Response) / nrow(dat) * 100, 0)
```

```{r, eval=TRUE, cache=FALSE}
# make dat be long format with respect to Response 
# now put it long so there are three rows for each Trial.s
b = melt(dat, measure.vars=c("Expected", "Near", "Far"))  
```

```{r, eval=TRUE, cache=FALSE, fig.width=4, fig.height=4}
# show overall distribution of responses
b2 <- summarySEwithin(b, measurevar='value', withinvars = 'variable')
b2$value=b2$value*100
b2$ci <- b2$ci * 100
ggplot(b2, aes(y=value, x=variable, fill=variable, ymin=value-ci, ymax=value+ci)) + 
  geom_bar(stat='identity', position='dodge') +
  scale_fill_grey("") + theme_bw() + theme(legend.key=element_blank(), aspect.ratio=1) + xlab("") + ylab("percent") +
  geom_errorbar(position=position_dodge(width=0.9), width=.2)
```

```{r, eval=TRUE, cache=FALSE}
# show distribution of responses broken down over number
b2 = summarySEwithin(b, measurevar="value", withinvars=c("Number","variable"))
b2$value=b2$value*100
b2$ci <- b2$ci * 100
ggplot(b2, aes(y=value, x=variable, fill=variable, ymin=value-ci, ymax=value+ci)) + 
  geom_bar(stat='identity', position='dodge') +
  scale_fill_grey("") + theme_bw() + theme(legend.key=element_blank(), aspect.ratio=1) + xlab("") + ylab("percent") +
  geom_errorbar(position=position_dodge(width=0.9), width=.2) +
  facet_grid(~Number)
```

```{r, eval=TRUE, cache=FALSE}
# show distribution of responses broken down over vagueness
b2 = summarySEwithin(b, measurevar="value", withinvars=c("Vagueness","variable"))
b2$value=b2$value*100
b2$ci <- b2$ci * 100
ggplot(b2, aes(y=value, x=variable, fill=variable, ymin=value-ci, ymax=value+ci)) + 
  geom_bar(stat='identity', position='dodge') +
  scale_fill_grey("") + theme_bw() + theme(legend.key=element_blank(), aspect.ratio=1) + xlab("") + ylab("percent") + 
  geom_errorbar(position=position_dodge(width=0.9), width=.2) +
  facet_grid(~Vagueness)
```

```{r, eval=TRUE, cache=FALSE}
# show distribution of responses broken down over number and vagueness
b2 = summarySEwithin(b, measurevar="value", withinvars=c("Number","Vagueness","variable"))
b2$value=b2$value*100
b2$ci <- b2$ci * 100
ggplot(b2, aes(y=value, x=variable, fill=variable, ymin=value-ci, ymax=value+ci)) + 
  geom_bar(stat='identity', position='dodge') +
  scale_fill_grey("") + theme_bw() + theme(legend.key=element_blank(), aspect.ratio=1) + xlab("") + ylab("percent") + 
  geom_errorbar(position=position_dodge(width=0.9), width=.2) +
  facet_grid(~Number+Vagueness)
```

```{r, eval=TRUE, cache=FALSE}
b2 = summarySEwithin(b, measurevar="value", withinvars=c("Number","Vagueness","f_Itm","variable"))
b2$value=b2$value*100
b2$ci <- b2$ci * 100
ggplot(b2, aes(y=value, x=variable, fill=variable, ymin=value-ci, ymax=value+ci)) + 
  geom_bar(stat='identity', position='dodge') +
  scale_fill_grey("") + theme_bw() + theme(legend.key=element_blank(), aspect.ratio=.75) + xlab("") + ylab("percent") +
  geom_errorbar(position=position_dodge(width=0.9), width=.2) +
  facet_grid(~Number+Vagueness~f_Itm)
```

```{r, eval=TRUE, cache=TRUE, warning=TRUE, message=TRUE}
lmer.bd.mm0 <- glmer(data=dat, 
                     Near ~ 
                       c_Num * c_Vag * c_Itm 
                     + (c_Num * c_Vag + c_Itm | Subject), 
                     family=binomial, 
                     control=glmerControl(optimizer="bobyqa"))
lmer.bd.summary <- summary(lmer.bd.mm0)
```

```{r, results='asis', eval=TRUE, cache=FALSE}
print(xtable(digits=3,lmer.bd.summary$coefficients,
             caption="The most maximal model of bd that converges"),caption.placement="top", table.placement='htbp', type='html')
```

```{r, fig.width=4, fig.height=4, eval=TRUE, cache=FALSE}
qqPlot(residuals(lmer.bd.mm0))
```


```{r, eval=TRUE, cache=FALSE, echo=TRUE}
beep("fanfare")
```

